---
title: "GO를 사용한 객체지향 프로그래밍 2019-12-23"
date: 2019-12-19 00:01:28 -0400
categories: Development
---

GO와 다른 객체지향 언어들의 차이에 대해 알아보자

## Go의 역사
2007년 3명의 구글의 개발자들이 C++의 복잡성이 싫어 개발을 시작
  - 켄 톰프슨 : 유닉스 , B언어, C언어, UTF8 개발 
  - 롭 파이크 : 인페르노, UTF8 개발
  - 로버트 그리즈머 : 크롬 자바스크립트 엔진 개발

## Go의 특징
1. 컴파일 속도가 매우 빠른 컴파일 언어
	- 이 때문에 Go는 컴파일 언어의 장점인 빠른 실행 속도를 가지면서 인터프리터 언어처럼 사용할 수 있다
2. 생산성이 높다
	- Go는 기본 라이브러리가 풍부하며, 써드파티 라이브러리가 많고, 코드가 간결하고, 키워드는 약 25개 정도로 적어 익히기 쉽다
3. 자동으로 맞춰주는 엄격한 코딩 포맷을 가지고 있다
	- 그래서 통일성을 가지며, 가독성이 좋아지는 장점이 있다
4. 강타입 언어라서 암시적 형 변환을 할 수 없다
	- 코딩이 번거로워질 수 있지만, 컴파일 과정에서 에러를 찾을 수 있다
5. 객체지향 언어들과 표현 방식이 매우 다르다 
	- 문법 자체는 익히기 쉽지만 Go로 제대로된 객체지향 프로그래밍을 하기 위해선 많은 숙련이 필요하다

## Go를 사용한 객체지향 프로그래밍
Go는 객체지향 언어지만 클래스, 상속, 오버로딩 등이 없으며 뿐만 아니라 인터페이스 또한 다른 언어들과 매우 다르다.
따라서 객체지향의 원칙이 중요한 것이 아니라 언어의 설계적 차원에서 구현하고자 하는 아키텍처가 정말로 필요로 하는 것이 무엇인지에 집중하게 도와준다.

## Go는 클래스개념이 없다.
Go는 객체지향 언어지만 전형적인 객체지향 언어와는 거리감이 있다.

클래스 내의 객체들을 통해 객체지향 프로그래밍을하는 자바, 파이썬 등과 달리 클래스라는 개념이 없다. 따라서 <mark>구조체</mark>를 생성하여 필드를 대신하고, <mark>포인터 리씨버</mark>라는 개념으로 메소드를 대신한다.

따라서 Go를 배울 때에는 클래스에 대한 생각을 버리고 내가 어떤 아키텍처를 어떻게 제작할 것인가에 대해 생각하는 것이 중요하다.

## 구조체 -> 메소드 연결을 통해서 타 언어의 클래스 형식처럼 사용이 가능하다. 
전형적인 객체지향의 언어라면 클래스 안에 생성자와 메소드가 함께 정의한다.

```java
// 자바, Rectangle은 클래스이다.
class Rectangle	{
	// Name, Width, Height 는 속성이다.
	String Name = new String();
	Float64 Width = 0;
	Float64 Height = 0;
 	Float Area() {
		return this.Width * this.Height
	}
}
```
하지만 GO는 <mark>구조체</mark>로 속성을 선언하고, 메소드는 <mark>함수 앞에 구조체 매개변수를 따로 받아</mark> 선언한다. 즉 클래스 안에 속성과 메서드를 모두 선언하는 JAVA보다는 C언어와 가깝다고 볼 수 있다.

```go
//고
type Rectangle struct {
    Name    string
    Width, Height float64
}

//
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}
```

## Go는 상속이 없다.
전형적인 객체지향의 언어라면 상속이라는 개념을 통해 ComicBook이라는 클래스가 Book이라는 클래스를 상속받아 확장하여 사용할 수 있다. 
```java
//자바, 책 클래스
class Book {
	private String Name;
	public Book(String Name) {
		this.Name = Name;
	}
}
// 책 클래스 확장판인 만화책 클래스
class ComicBook extends Book {
	private String publisher;
	public ComicBook(String Name, String Publisher) {
		super(Name);
		this.publisher = Publisher;
	}
}
```

하지만 GO는 상속 역시 클래스-클래스가 아닌 <mark>구조체-구조체 임베딩</mark>을 통하여 대신한다.
```go
// Person 구조체
type Person struct { 
	name string
	age  int
}
// Student 구조체 내에 Person 구조체를 임베딩
type Student struct {
	p      Person 
	school string
	grade  int
}

// Person 구조체의 greeting 메서드
func (p *Person) greeting() { 
	fmt.Println("Hello~")
}


func main() {
	var s Student
	s.p.greeting() // Hello~
}
```

## Go는 구현 방식이 다르다.
전형적인 객체지향 언어에서는 인터페이스를 생성하고 인터페이스를 구현하는 클래스를 만들 수 있다.
```java
public interface Country {
	void gdp(String country);
	void gnp(String country);
}

public class Countryimpl implements Country {
	public void gdp(String country) {
		System.out.println("해당 나라의 gdp");
	}
	public void gnp(String country) {
		System.out.println("해당 나라의 gnp");
	}
}
```

하지만 GO는 구조체가 속성들의 모임이라면 인터페이스는 메서드들의 모임이다.
<br>
 인터페이스를 구현하는 메서드를 만들고 싶다면 단순히 그 <mark>인터페이스가 갖는 모든 메서드들을 구조체 리씨버</mark>를 통해 구현하면 된다.
 <br>
이 코드를 요약하자면 <mark>"굳이 동물인지 검사할 필요없이, 뛰면 동물이라고 봐라"</mark>이며, 이 방식은 덕 타이핑 방식이다.

```go
// Java에는 interface와 class를 분리하고 implements 키워드를 통해 구현한다.
// Go에는 interface를 구현을 한 메서드는 모두 구현된 메서드라고 본다.
type animal interface{
    run()
}

type Dog struct {
	name   string
	weight int
}

type Cat struct {
	name   string
	weight int
}

func (a Dog) run() {
	fmt.Println(animal.name, "dog is running now!")
}

func (a Cat) run() {
	fmt.Println(animal.name, "cat is running now!")
}

func main() {
	dog1 := Dog{dog1, 40}
	cat1 := Cat{cat1, 20}
	dog1.run() //dog1 dog is running now!
	cat1.run() //cat1 cat is running now!
}
```

## 포인터가 있다
Go는 전형적인 객체지향 언어들과는 달리 포인터를 통해 <mark>얕은 복사</mark>를 사용할 수 있다.
그렇기 때문에 StayTheSame()에서는 m.a, m.b의 값이 변경되지 않고 
포인터로 값을 받는 Mutate()에서만 m.a, m.b의 값이 변경된다.
```go
type Mutatable struct {
    a int
    b int
}

func (m Mutatable) StayTheSame() {
	// 실제 값은 변경되지 않는다.
    m.a = 5
	m.b = 7
	// 메서드가 끝나면 5, 7은 소멸된다.
}

func (m *Mutatable) Mutate() {
	// 포인터를 통해 받았으므로 실제 값이 변경된다.
    m.a = 5
	m.b = 7
	// 다시 변경하지 않는 이상 영구적으로 5, 7로 쓸 수 있다.
}

```

## 대/소문자만으로 Public과 Private를 결정할 수 있다.
다음은 구조체를 이용한 예시 코드이다.
```go
// //대문자로 선언 - 외부에서도 사용 가능
type Car struct { 
	name    string 
	color   string 
	company string 
	detail  spec
}

// //소문자로 선언 - 내부에서만 사용 가능
type spec struct { 
	length int 
	height int 
	width  int 
}
```


## 인터페이스 타입이라는 게 있다.
Go에서 모든 Type을 나타내기 위해 빈 인터페이스를 사용한다. 즉, 빈 인터페이스는 어떠한 타입도 담을 수 있는 컨테이너라고 볼 수 있으며, 여러 다른 언어에서 흔히 일컫는 Dynamic Type 이라고 볼 수 있다. (empty interface는 C#, Java 에서 object라 볼 수 있으며, C/C++ 에서는 void* 와 같다고 볼 수 있다)
아래 예제에서 인터페이스 타입 x는 정수 1을 담았다가 다시 문자열 Tom을 담고 있는데, 실행 결과는 마지막에 담은 Tom을 출력한다.

```go
func main() {
    var x interface{}
    x = 1 
    x = "Tom"
    printIt(x)
}
 
func printIt(v interface{}) {
    fmt.Println(v) //Tom
}
```

빈 인터페이스는 아래와 같이 모든 타입을 받고 반환시킬 수 있다.

```go
//런타임에 형 변환을 한 후, 정적 타입의 값으로 변경해서 넘긴다.
func checkType(a interface{}) {
	switch a.(type) {
	case bool:
		fmt.Println("This is bool,", a)
	case int, int8, int16, int32, int64:
		fmt.Println("This is int,", a)
	case float32, float64:
		fmt.Println("This is float,", a)
	case nil:
		fmt.Println("This is nil,", a)
	case string:
		fmt.Println("This is string,", a)
	default:
		fmt.Println("This is not bool, int, float, nil, string!,", a)
	}
}
```





