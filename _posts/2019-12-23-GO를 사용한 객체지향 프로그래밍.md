---
title: "GO를 사용한 객체지향 프로그래밍 2019-12-23"
date: 2019-12-19 00:01:28 -0400
categories: Development
---

## Go는 클래스개념이 없다.
Go는 객체지향 언어지만 전형적인 객체지향 언어와는 거리감이 있다.

객체 내의 속성들을 통해 객체지향 프로그래밍을하는 자바, 파이썬 등과 달리 클래스 멤버라는 개념이 없다. 따라서 <mark>구조체</mark>를 생성하여 속성을 대신하고, <mark>포인터 리씨버</mark>라는 개념으로 메소드를 대신한다.

따라서 Go를 배울 때에는 클래스에 대한 생각을 버리고 C언어처럼 절차지향 언어를 객체지향적으로 프로그래밍 한다고 생각해야 한다.

## 구조체 -> 메소드 연결을 통해서 타 언어의 클래스 형식처럼 사용이 가능하다. 
전형적인 객체지향의 언어라면 클래스 안에 생성자와 메소드가 함께 정의한다.

```java
// Rectangle은 클래스이자 객체이다.
class Rectangle	{
	// Name, Width, Height 는 속성이다.
	String Name = new String();
	Float64 Width = 0;
	Float64 Height = 0;
 	Float Area() {
		return this.Width * this.Height
	}
}
```
하지만 GO는 <mark>구조체</mark>로 속성을 선언하고, 메소드는 함수처럼 선언한다. 즉 클래스 안에 속성과 메서드를 모두 선언하는 JAVA보다는 C언어와 가깝다고 볼 수 있다.

```go
//고
type Rectangle struct {
    Name    string
    Width, Height float64
}

// (r Rectangle)
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}
```

## Go는 상속이 없다.
//

## 포인터가 있다
Go는 전형적인 객체지향 언어들과는 달리 포인터를 통해 Pass by Reference를 사용할 수 있다.
그렇기 때문에 StayTheSame()에서는 m.a, m.b의 값이 변경되지 않고 
포인터로 값을 받는 Mutate()에서만 m.a, m.b의 값이 변경된다.
```go
type Mutatable struct {
    a int
    b int
}

func (m Mutatable) StayTheSame() {
	// 실제 값은 변경되지 않는다.
    m.a = 5
	m.b = 7
	// 메서드가 끝나면 5, 7은 소멸된다.
}

func (m *Mutatable) Mutate() {
	// 포인터를 통해 받았으므로 실제 값이 변경된다.
    m.a = 5
	m.b = 7
	// 다시 변경하지 않는 이상 영구적으로 5, 7로 쓸 수 있다.
}

```

## 대/소문자만으로 Public과 Private를 결정할 수 있다.
다음은 중첩 구조체를 이용한 예시 코드이다.
```go
// Public : 어떠한 파일에서도 사용 가능 
type Car struct { //대문자로 선언 - 외부에서도 사용 가능
	name    string 
	color   string 
	company string 
	detail  spec
}

// Private : 선언되어 있는 파일에서만 사용 가능
type spec struct { //소문자로 선언 - 내부에서만 사용 가능
	length int 
	height int 
	width  int 
}
```

## 인터페이스
Go의 인터페이스 기능은 딱 2가지이다.
- 인터페이스 암시적 충족
- 인터페이스 타입

Go는 '오리처럼 걷고, 소리내고, 헤엄치면 오리라고 볼 수 있다' 라는 덕타이핑의 특징을 보인다.

이를 통해 직관적으로 어떤 메서드를 개발해야할지 한눈에 알 수 있다.
```go
// Java에는 implements를 통해 interface파일을 분리한다.
// Go에는 implements 키워드가 없으므로 파일을 분리하지 않는다.
type animal interface{
    run()
}

type Dog struct {
	name   string
	weight int
}

type Cat struct {
	name   string
	weight int
}

func (a Dog) run() {
	fmt.Println(animal.name, "dog is running now!")
}

func (a Cat) run() {
	fmt.Println(animal.name, "cat is running now!")
}

func main() {
	dog1 := Dog{dog1, 40}
	cat1 := Cat{cat1, 20}
	dog1.run() //dog1 dog is running now!
	cat1.run() //cat1 cat is running now!
}
```

빈 인터페이스는 아래와 같이 모든 타입을 받고 반환시킬 수 있다. 
컴파일 언어인 go가 interface{}를 통해 개발 속도와 실행 속도 모두 빠른 것이다.
```go
//런타임에 형 변환을 한 후, 정적 타입의 값으로 변경해서 넘긴다.
func checkType(a interface{}) {
	switch a.(type) {
	case bool:
		fmt.Println("This is bool,", a)
	case int, int8, int16, int32, int64:
		fmt.Println("This is int,", a)
	case float32, float64:
		fmt.Println("This is float,", a)
	case nil:
		fmt.Println("This is nil,", a)
	case string:
		fmt.Println("This is string,", a)
	default:
		fmt.Println("This is not bool, int, float, nil, string!,", a)
	}
}
```





