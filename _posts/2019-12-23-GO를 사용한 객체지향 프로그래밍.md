---
title: "GO를 사용한 객체지향 프로그래밍 2019-12-23"
date: 2019-12-19 00:01:28 -0400
categories: Development
---

GO와 다른 객체지향 언어들의 차이에 대해 알아보자

## Go의 역사
2007년 3명의 구글의 개발자들이 C++의 복잡성이 싫어 개발을 시작
  - 켄 톰프슨 : 유닉스 , B언어, C언어, UTF8 개발 
  - 롭 파이크 : 인페르노, UTF8 개발
  - 로버트 그리즈머 : 크롬 자바스크립트 엔진 개발

## Go를 사용한 객체지향 프로그래밍
Go는 객체지향 언어지만 클래스, 상속, 구현이 없다.
따라서 객체지향의 원칙이 중요한 것이 아니라 언어의 설계적 차원에서 구현하고자 하는 아키텍처가 정말로 필요로 하는 것이 무엇인지에 집중하게 도와준다.

## Go는 클래스개념이 없다.
Go는 객체지향 언어지만 전형적인 객체지향 언어와는 거리감이 있다.

클래스 내의 객체들을 통해 객체지향 프로그래밍을하는 자바, 파이썬 등과 달리 클래스라는 개념이 없다. 따라서 <mark>구조체</mark>를 생성하여 속성을 대신하고, <mark>포인터 리씨버</mark>라는 개념으로 메소드를 대신한다.

따라서 Go를 배울 때에는 클래스에 대한 생각을 버리고 C언어처럼 절차지향 언어를 객체지향적으로 프로그래밍 한다고 생각해야 한다.

## 구조체 -> 메소드 연결을 통해서 타 언어의 클래스 형식처럼 사용이 가능하다. 
전형적인 객체지향의 언어라면 클래스 안에 생성자와 메소드가 함께 정의한다.

```java
// 자바, Rectangle은 클래스이다.
class Rectangle	{
	// Name, Width, Height 는 속성이다.
	String Name = new String();
	Float64 Width = 0;
	Float64 Height = 0;
 	Float Area() {
		return this.Width * this.Height
	}
}
```
하지만 GO는 <mark>구조체</mark>로 속성을 선언하고, 메소드는 <mark>함수 앞에 구조체 매개변수를 따로 받아</mark> 선언한다. 즉 클래스 안에 속성과 메서드를 모두 선언하는 JAVA보다는 C언어와 가깝다고 볼 수 있다.

```go
//고
type Rectangle struct {
    Name    string
    Width, Height float64
}

//
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}
```

## Go는 상속이 없다.
전형적인 객체지향의 언어라면 상속이라는 개념을 통해 B라는 클래스가 A라는 클래스를 상속하면 확장하여 사용할 수 있다. 
```java
//자바, 책 클래스
class Book {
	private String Name;
	public Book(String Name) {
		this.Name = Name;
	}
}
// 책 클래스 확장판인 만화책 클래스
class ComicBook extends Book {
	private String publisher;
	public ComicBook(String Name, String Publisher) {
		super(Name);
		this.publisher = Publisher;
	}
}
```

하지만 GO는 상속 역시 클래스를 대신하여 <mark>구조체 임베딩</mark>을 통하여 대신한다.
```go
// 구조체 임베딩
type Person struct { // 사람 구조체 정의
	name string
	age  int
}

func (p *Person) greeting() { // 인사(greeting) 메서드 작성
	fmt.Println("Hello~")
}

type Student struct {
	p      Person // Student 구조체 안에 Person 구조체를 넣음으로써 상속 관계가 만들어짐
	school string
	grade  int
}

func main() {
	var s Student
	s.p.greeting() // Hello~
}
```

## Go는 구현이 없다.
전형적인 객체지향 언어에서는 인터페이스를 생성하고 인터페이스를 구현하는 클래스를 만들 수 있다.
```java
public interface Country {
	void gdp(String country);
	void gnp(String country);
}

public class Countryimpl implements Country {
	public void gdp(String country) {
		System.out.println("해당 나라의 gdp");
	}
	public void gnp(String country) {
		System.out.println("해당 나라의 gnp");
	}
}
```

하지만 go에서는 interface를 생성하고 메서드를 정의하면 그 메서드를 구현한 모든 구조체들은 모두 인터페이스 타입으로 사용할 수 있다.
```go
// Java에는 implements를 통해 interface파일을 분리한다.
// Go에는 implements 키워드가 없으므로 파일을 분리하지 않는다.
type animal interface{
    run()
}

type Dog struct {
	name   string
	weight int
}

type Cat struct {
	name   string
	weight int
}

func (a Dog) run() {
	fmt.Println(animal.name, "dog is running now!")
}

func (a Cat) run() {
	fmt.Println(animal.name, "cat is running now!")
}

func main() {
	dog1 := Dog{dog1, 40}
	cat1 := Cat{cat1, 20}
	dog1.run() //dog1 dog is running now!
	cat1.run() //cat1 cat is running now!
}
```

## 포인터가 있다
Go는 전형적인 객체지향 언어들과는 달리 포인터를 통해 Pass by Reference를 사용할 수 있다.
그렇기 때문에 StayTheSame()에서는 m.a, m.b의 값이 변경되지 않고 
포인터로 값을 받는 Mutate()에서만 m.a, m.b의 값이 변경된다.
```go
type Mutatable struct {
    a int
    b int
}

func (m Mutatable) StayTheSame() {
	// 실제 값은 변경되지 않는다.
    m.a = 5
	m.b = 7
	// 메서드가 끝나면 5, 7은 소멸된다.
}

func (m *Mutatable) Mutate() {
	// 포인터를 통해 받았으므로 실제 값이 변경된다.
    m.a = 5
	m.b = 7
	// 다시 변경하지 않는 이상 영구적으로 5, 7로 쓸 수 있다.
}

```

## 대/소문자만으로 Public과 Private를 결정할 수 있다.
다음은 중첩 구조체를 이용한 예시 코드이다.
```go
// Public : 어떠한 파일에서도 사용 가능 
type Car struct { //대문자로 선언 - 외부에서도 사용 가능
	name    string 
	color   string 
	company string 
	detail  spec
}

// Private : 선언되어 있는 파일에서만 사용 가능
type spec struct { //소문자로 선언 - 내부에서만 사용 가능
	length int 
	height int 
	width  int 
}
```


빈 인터페이스는 아래와 같이 모든 타입을 받고 반환시킬 수 있다. 
컴파일 언어인 go가 interface{}를 통해 개발 속도와 실행 속도 모두 빠른 것이다.
```go
//런타임에 형 변환을 한 후, 정적 타입의 값으로 변경해서 넘긴다.
func checkType(a interface{}) {
	switch a.(type) {
	case bool:
		fmt.Println("This is bool,", a)
	case int, int8, int16, int32, int64:
		fmt.Println("This is int,", a)
	case float32, float64:
		fmt.Println("This is float,", a)
	case nil:
		fmt.Println("This is nil,", a)
	case string:
		fmt.Println("This is string,", a)
	default:
		fmt.Println("This is not bool, int, float, nil, string!,", a)
	}
}
```





