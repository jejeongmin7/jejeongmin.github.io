---
title: "객체지향의 3가지 디자인 패턴 2021-03-28"
date: 2021-03-28 00:01:28 -0400
categories: Development
---

객체지향적 코드를 쉽게 이해하기 위해 3가지 디자인 패턴에 대해 공부하고 정리했습니다
<hr/>

# [ 객체지향 디자인 패턴 ]
복잡한 구조를 한 단어로 정의함으로서 협업을 할 때에 의사소통을 효율적으로 할 수 있다<br>
기존 코드의 문제점을 해결할 수 있어 효율적으로 코드를 개선할 수 있다

## [ 싱글톤 패턴 ]
한 클래스에서 단 하나의 객체만을 생성하게 강제하는 패턴<br>

```java
// 외부에서 인스턴스 생성을 막기위해 생성자를 private 으로 만든다
// static 으로 선언 시 데이터 영역에 저장되어 객체 생성 없이 접근할 수 있다

public class Singleton {
    private Singleton() {};
    private static Singleton object = null;

    public static Singleton getInstance() {
        if (object == null) {
            object = new Singleton();
            System.out.println("싱글톤 객체 최초 생성됨");
        }else {
            System.out.println("싱글톤 객체 이미 생성됨");
        }
        return object;
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance(); //싱글톤 객체 최초 생성됨
        Singleton singleton2 = Singleton.getInstance(); //싱글톤 객체 이미 생성됨 
        Singleton singleton3 = Singleton.getInstance(); //싱글톤 객체 이미 생성됨
        Singleton singleton4 = Singleton.getInstance(); //싱글톤 객체 이미 생성됨
        Singleton singleton5 = Singleton.getInstance(); //싱글톤 객체 이미 생성됨
    }
}
```

## [ 싱글톤 패턴 특징 ]
어떤 클래스의 객체가, 해당 프로세스에서 딱 하나만 만들어져 있어야 할 때 사용한다<br>
예를 들어 다크 모드를 적용할 경우 모든 페이지에서 반드시 같은 객체를 사용해야 한다<br>
<br>

## [ 전략 패턴 ]
옵션들마다의 행동을 모듈화해서 독립적이고 상호 교체 가능하게 만드는 패턴
```java
public interface PaymentService {
    public void pay(int price);
}

public class OrderService {
    public void payment(PaymentService paymentService, int price) {
        paymentService.pay(price);
    }
}

public class CardService implements PaymentService{
    @Override
    public void pay(int price) {
        System.out.println(price + " 원이 카드로 결제되었습니다");
    }
}

public class MoneyService implements PaymentService {
    @Override
    public void pay(int price) {
        System.out.println(price + " 원이 현금으로 결제되었습니다");
    }
}

public class Main {
    public static void main (String[] args) {
        OrderService orderService = new OrderService();
        PaymentService cardService = new CardService();
        PaymentService moneyService = new MoneyService();
        orderService.payment(moneyService, 3000); //3000 원이 현금으로 결제되었습니다
        orderService.payment(cardService, 5000); //5000 원이 카드로 결제되었습니다 
        orderService.payment(moneyService, 8000); //8000 원이 현금으로 결제되었습니다 
        orderService.payment(cardService, 10000); //10000 원이 카드로 결제되었습니다
    }
}
```

## [ 전략 패턴 특징 ]
일관된 동작이 각 전략에 따라 변경될 때 사용한다<br>
코드에서 '결제'라는 행위는 동작이고 '결제 타입'이 전략이라 볼 수 있다<br>
<br>

## [ 상태 패턴 ]
객체가 상태에 따라 다른 행동을 할 수 있도록 위임하는 패턴
```java
public interface PowerState {
    public void setPowerState(Power power);
}

public class Power {
    PowerState powerState = new PowerOff();
    public void switchPowerState(PowerState powerState) {
        this.powerState = powerState;
    }
    public void onSwitch() {
        powerState.setPowerState(this);
    }
}

public class PowerOn implements PowerState {
    @Override
    public void setPowerState(Power power) {
        System.out.println("전원이 꺼졌습니다");
        power.switchPowerState(new PowerOff());
    }
}

public class PowerOff implements PowerState {
    @Override
    public void setPowerState(Power power) {
        System.out.println("전원이 켜졌습니다");
        power.switchPowerState(new PowerOn());
    }
}

public class Main {
    public static void main (String[] args) {
        Power power = new Power();
        power.onSwitch(); //전원이 켜졌습니다
        power.onSwitch(); //전원이 꺼졌습니다 
        power.onSwitch(); //전원이 켜졌습니다
        power.onSwitch(); //전원이 꺼졌습니다 
        power.onSwitch(); //전원이 켜졌습니다
        power.onSwitch(); //전원이 꺼졌습니다
    }
}
```

## [ 상태 패턴 특징 ]
전략 패턴과 상당히 유사하며 전략 패턴은 상속을 대체하려는 목적이라면 상태 패턴은 조건문들을 대체하려는 목적으로 사용된다
<br>


