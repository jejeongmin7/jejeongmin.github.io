---
title: "백엔드 면접 준비(1) 알고리즘 2021-03-12"
date: 2021-03-12 00:01:28 -0400
categories: Development
---

고등학교 3학년이 되니 저도 이제 취업준비생이 되었습니다. 백엔드 분야로 면접 준비를 하는 중인데, 첫 번째로 알고리즘에 대해 작성해보려 합니다
<hr/>

# ☀️ 알고리즘

## Bubble Sort(거품 정렬)
```
서로 인접한 두 원소의 대소를 비교하고, 자리를 교환하며 정렬하는 알고리즘
```

```python
# PYTHON으로 직접 구현해 본 거품 정렬입니다
def bubble_sort(arr):
  for i in range(len(arr)):
    for j in range(len(arr)-1):
      if arr[j] > arr[j+1]:
        arr[j], arr[j+1] = arr[j+1], arr[j]
  return arr

print(bubble_sort([5, 4, 13, 1, 3])) 
```


1. 앞에서부터 모든 원소를 차례대로 비교한다.
2. 큰 원소가 오른쪽으로 이동하게 된다.

```
시간복잡도 : O(n^2)
공간복잡도 : O(n)
```

이중 반복문으로 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간복잡도가 동일하다. <br><br>
주어진 배열 안에서 교환을 통해 정렬이 수행되므로 공간복잡도는 O(n)이다.

## GIF로 복습하는 Bubble Sort(거품 정렬)
![bubble-sort-001](https://user-images.githubusercontent.com/52072077/110873489-344dd500-8315-11eb-9b27-47551806d814.gif)

```
구현이 매우 간단하지만 굉장히 비효율적이다
안정 정렬 => 정렬 후에 같은 값인 요소의 순서가 보장됨
제자리 정렬 => 주어진 메모리 공간 외에 추가적인 공간을 필요로 하지 않음
```

## Selection Sort(선택 정렬)
```
배열 중 최솟값을 찾아 맨 앞에 위치한 값과 교체하는 알고리즘
```

```python
# Python으로 직접 구현해 본 선택 정렬입니다
def selection_sort(arr):
  indexMin = 0
  for i in range(len(arr)):
    indexMin = i
    for j in range(i+1, len(arr)):
      if arr[indexMin] > arr[j]:
        indexMin = j
    arr[i], arr[indexMin] = arr[indexMin], arr[i]
  return arr

print(selection_sort([7, 9, 18, 2, 6, 31, 0]))
```

1. 배열의 맨 앞 값을 선택한다

2. 내가 선택한 값 이후에 있는 원소들 중 최솟값을 찾는다

3. 내가 선택한 값과 위치를 바꾼다

```
시간복잡도 : O(n^2)
공간복잡도 : O(n)
```

이중 반복문으로 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간복잡도가 동일하다. <br><br>
주어진 배열 안에서 교환을 통해 정렬이 수행되므로 공간복잡도는 O(n)이다.

## GIF로 복습하는 Selection Sort(선택 정렬)
![selection-sort-001](https://user-images.githubusercontent.com/52072077/110880004-47ff3880-8321-11eb-9f62-40699fa2c3ba.gif)

```
구현이 간편하고, Bubble Sort와 유사하지만 조금 더 빠르다
불안정 정렬 => 정렬 후에 같은 값인 요소의 순서가 보장되지 않음
제자리 정렬 => 주어진 메모리 공간 외에 추가적인 공간을 필요로 하지 않음
```

## Insertion Sort(삽입 정렬)
```
삽입할 위치를 정한 후, 원소들을 뒤로 옮긴후 지정된 자리에 자료를 삽입하는 알고리즘
```

```python
# Python으로 직접 구현해 본 삽입 정렬입니다
def insertion_sort(arr):
  for i in range(1, len(arr)):
    temp = arr[i]
    prev = i - 1
    while prev >= 0 and arr[prev] > temp:
      arr[prev+1] = arr[prev]
      prev -= 1
    arr[prev+1] = temp
  return arr

print(insertion_sort([5, 22, 31, 1, 7, 14]))
```

1. 두 번째 위치부터 탐색을 시작해서 현재 인덱스의 값과 이전 원소 인덱스를 저장함
2. 이전 위치 인덱스가 음수가 되지 않고, 현재 인덱스의 값보다 클 때 값을 교환하고 더 이전 위치를 가리키게 한다
3. '2번' 과정의 반복문이 끝나면 prev가 현재 인덱스의 값보다 작은 값들 중 최댓값의 위치를 가리키게 되므로 (prev + 1)에 현재 인덱스의 값을 넣어준다

```
시간복잡도 : 최선 : O(n), 최악 : O(n^2)
공간복잡도 : O(n)
```

이미 정렬이 되어 있는 경우, 한 번씩밖에 비교를 안하므로 O(n)으로 최고의 정렬 알고리즘이 된다<br>
하지만, 역으로 정렬되어 있을 경우 거품, 선택 정렬과 마찬가지로 O(n^2)가 된다<br>
주어진 배열 안에서 교환을 통해 정렬이 수행되므로 공간복잡도는 O(n)이다.

## GIF로 복습하는 Insertion Sort(삽입 정렬)
![insertion-sort-001](https://user-images.githubusercontent.com/52072077/110882091-c3161e00-8324-11eb-81e4-23a8a584e432.gif)

```
때에 따라 매우 효율적일 수도 매우 비효율적일 수도 있다
안정 정렬 => 정렬 후에 같은 값인 요소의 순서가 보장됨
제자리 정렬 => 주어진 메모리 공간 외에 추가적인 공간을 필요로 하지 않음
```

## Quick Sort(퀵 정렬)
```
어떤 알고리즘
```

```python
# Python으로 직접 구현해 본 삽입 정렬입니다
```

1. 머를 한다
2. 머를 한다

```
시간복잡도 : 
공간복잡도 :
```

어떻게 어떻게 하기 때문에 시간복잡도는 이지랄이고
어떻게 어떻게해서 공간복잡도는 이랄지다

## GIF로 복습하는 Quick Sort(퀵 정렬)
![quick-sort-001](https://user-images.githubusercontent.com/52072077/110882211-f193f900-8324-11eb-8013-65c56bc49fa1.gif)

```
구현이 어떻고 뭐뭐뭐하다
불안정 정렬 => 정렬 후에 같은 값인 요소의 순서가 보장되지 않음
제자리 정렬 => 주어진 메모리 공간 외에 추가적인 공간을 필요로 하지 않음
```