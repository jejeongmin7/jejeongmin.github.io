---
title: "백엔드 면접 준비 2021-03-12"
date: 2021-03-12 00:01:28 -0400
categories: Development
---

고등학교 3학년이 되니 저도 이제 취업준비생이 되었습니다. 백엔드 분야로 먼저 면접 준비를 해보려 합니다.
<hr/>

# ☀️ 알고리즘

## Bubble Sort(거품 정렬)
```
서로 인접한 두 원소의 대소를 비교하고, 자리를 교환하며 정렬하는 알고리즘
```

```python
# PYTHON으로 직접 구현해 본 거품 정렬입니다
def bubble_sort(arr):
  for i in range(len(arr)):
    for j in range(len(arr)-1):
      if arr[j] > arr[j+1]:
        arr[j], arr[j+1] = arr[j+1], arr[j]
  return arr

print(bubble_sort([5, 4, 13, 1, 3])) 
```


1. 앞에서부터 모든 원소를 차례대로 비교한다.
2. 큰 원소가 오른쪽으로 이동하게 된다.

```
시간복잡도 : O(n^2)
공간복잡도 : O(n)
```

이중 반복문으로 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간복잡도가 동일하다. <br><br>
주어진 배열 안에서 교환을 통해 정렬이 수행되므로 공간복잡도는 O(n)이다.

## GIF로 복습하는 Bubble Sort(거품 정렬)
![bubble-sort-001](https://user-images.githubusercontent.com/52072077/110873489-344dd500-8315-11eb-9b27-47551806d814.gif)

```
구현이 매우 간단하지만 굉장히 비효율적이다
안정 정렬 => 정렬 후에 같은 값인 요소의 순서가 보장됨
제자리 정렬 => 주어진 메모리 공간 외에 추가적인 공간을 필요로 하지 않음
```

## Selection Sort(선택 정렬)
```
배열 중 최솟값을 찾아 맨 앞에 위치한 값과 교체하는 알고리즘
```

```python
# Python으로 직접 구현해 본 선택 정렬입니다
def selection_sort(arr):
  indexMin = 0
  for i in range(len(arr)):
    indexMin = i
    for j in range(i+1, len(arr)):
      if arr[indexMin] > arr[j]:
        indexMin = j
    arr[i], arr[indexMin] = arr[indexMin], arr[i]
  return arr

print(selection_sort([7, 9, 18, 2, 6, 31, 0]))
```

1. 배열의 맨 앞 값을 선택한다

2. 내가 선택한 값 이후에 있는 원소들 중 최솟값을 찾는다

3. 내가 선택한 값과 위치를 바꾼다

```
시간복잡도 : O(n^2)
공간복잡도 : O(n)
```

이중 반복문으로 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간복잡도가 동일하다. <br><br>
주어진 배열 안에서 교환을 통해 정렬이 수행되므로 공간복잡도는 O(n)이다.

## GIF로 복습하는 Selection Sort(선택 정렬)
![selection-sort-001](https://user-images.githubusercontent.com/52072077/110880004-47ff3880-8321-11eb-9f62-40699fa2c3ba.gif)

```
구현이 간편하고, Bubble Sort와 유사하지만 조금 더 빠르다
불안정 정렬 => 정렬 후에 같은 값인 요소의 순서가 보장되지 않음
제자리 정렬 => 주어진 메모리 공간 외에 추가적인 공간을 필요로 하지 않음
```

