---
title: "Spring IOC & DI & AOP 2021-04-10"
date: 2021-04-10 00:01:28 -0400
categories: Development
---

계층형 아키텍처로 Spring을 개발하면서 꼭 알고 있어야하는 Spring의 핵심 3대 요소에 대해 요약해봅니다
<hr/>

# IoC (Inversion of Control, 제어의 역전)
IoC란 <mark>객체의 제어권을 프레임워크에게 맡기는 것을 컨테이너라 하는데, 이를 부르는 개념</mark>이다<br><br>
객체에 대한 제어권이 개발자가 아닌 컨테이너에게 넘어가면서 객체의 생성과 관리의 모든 것을 컨테이너가 맡아서 하게 된다<br><br>
이를 두고 제어권이 역전되었다고 하여 IoC(Inversion of Control, 제어의 역전)라고 한다<br><br>
아래 예시 코드를 보면 이해하기 쉽다

```java
// 개발자가 직접 객체를 생성하는 코드 

public Class Controller {

    private Service service = new Service();

}
```
위 코드에서 Service 클래스를 직접 인스턴스화하여 개발자가 객체를 제어하고 있다<br><br>
하지만 아래 코드에서는 컨테이너가 생성한 객체를 인스턴스화하지 않고 사용만 한다

```java
// 컨테이너에 의해 생성된 객체를 사용만 하는 코드 

public Class Controller {

    @Autowired
    private Service service;

}
```

스프링에서 자주 볼 수 있는 표현이다<br><br>
Service라는 객체를 @Autowired를 통해 스프링 컨테이너에게서 생성된 객체를 주입받아 사용할 수 있다<br><br>
(단, 스프링 컨테이너가 관리할 객체에는 Bean이 등록되어 있어야 한다)<br><br>
IoC를 통해 개발자는 객체 관리에 신경쓰지 않고 비즈니스 로직만 생각할 수 있다<br><br>

# DI (Dependency Injection, 의존성 주입)
의존성 주입이란 <mark>IoC의 형태로 오브젝트의 인스턴스 변수를 직접 인스턴스화하지 않고 DI 컨테이너가 애플리케이션 실행 시점에 인스턴스화해둔 인스턴스를 사용하는 것</mark>이다<br><br>
의존성이란 서로 다른 객체간에 의존 관계가 되어 있다는 말이다, 코드를 보자 
```java
public class Controller {

    @Autowired
    private Service service;

    public void getServiceInfo() {
        service.getInfo();
    }

}
```
위 코드는 Service 객체에 변경사항이 생기면 Controller 객체가 영향을 받으므로, Controller -> Service 간에 의존성(의존 관계)이 있다고 표현한다<br><br>

그렇다면 주입은 무슨 말일까?<br><br>
주입이란 외부로부터 사용할 객체의 주소값을 전달받아 사용하는 방식이다<br><br>

클래스에서 새로운 객체를 생성하지 않고 DI 컨테이너가 건네주는 인스턴스를 인터페이스로 받음으로써 인터페이스 기반의 컴퍼넌트화를 구현할 수 있다<br><br>

DI 컨테이너의 구상 클래스 인스턴스화는 1회만 실행되고 Singleton처럼 하나의 객체로 필요한 곳에서 사용된다<br><br>

# AOP (Aspect Oriented Programming, 관점 지향 프로그래밍)

AOP란 <mark>여러 오브젝트에 나타나는 부가적인 기능을 비즈니스 로직에서 분리하여 재사용하는 기법</mark>이다<br><br>


먼저 Target이 될 메서드에 사용할 Aspect 어노테이션을 등록한다
```java
@AuthorizationCheck //Aspect
@GetMapping("/getInfo")
public Response getInfo(~~~) {
    // ~~~
    // return Response ~~~
}
```

그리고 Aspect 어노테이션을 생성한다 
```java
@Target(ElementType.METHOD) //실행 시점 설정
@Retention(RetentionPolicy.RUNTIME) //유지될 시간 설정
public @interface AuthorizationCheck {
}
```

어노테이션을 생성했으면 실제 Aspect와 Advice를 만든다 
```java
@Aspect
public class AuthorizationAspect {

    @Pointcut("@annotation(매핑할 어노테이션 위치)")
    public void authorizationCheck() {}

    @Before("authorizationCheck() && args(request)")
    public boolean isExist(HttpServletRequest request) {
        if (request.getAttribute("user") == null) {
            throw new AuthorizationException("유저 정보가 없음");
        }
        return true;
    }

}
```

@Pointcut은 Advice를 적용할 어노테이션과 매핑하는 것이고, 어떤 부가적인 기능을 언제 사용할지 정의하는 것을 Advice라 한다<br>
Advice의 종류로는 아래 5가지가 있다<br>
```
@Before - 메서드가 실행되기 전에
@AfterReturning - 메서드가 정상적으로 사용되었을 때
@AfterThrowing - 메서드가 예외를 발생시켰을 때 
@After - 메서드가 끝났을 때
@Around - 비즈니스 로직 전후 모두에 실행되어야 할 때
```
<br>

AOP는 시간 측정, 성능 검사, 로깅 등 다양한 부가적인 기능에서 사용된다
