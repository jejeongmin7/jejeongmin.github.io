---
title: "객체지향의 5가지 원칙 SOLID 2021-05-12"
date: 2021-05-12 00:01:28 -0400
categories: Development
---

객체지향의 5가지 원칙인 SRP, OCP, LSP, ISP, DIP 에 대해 알아봅니다.
<hr>

## [ SRP (Single Responsibility Principle, 단일 책임 원칙) ]
클래스는 단 하나의 목적을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다.
<br>
이는 한 클래스에서 여러 목적을 가지면 안 된다는 것입니다.

## [ SRP를 준수하지 않은 예제 ]
아래는 클래스에서 여러 목적을 가지고 있는 예제입니다.
<br>
유저와 관련된 목적만을 가져야 하는데 물품 구매와 관련된 목적을 가지고 있습니다. 이는 코드가 길어질수록 유지보수가 힘듭니다.

```java
class UserService {
    void signIn() {
        System.out.println("로그인 완료");
    }
    void signUp() {
        System.out.println("회원가입 완료");
    }
    void buyItem() {
        System.out.println("물품 구매 완료");
    }
}
```

## [ SRP를 준수한 예제 ]
아래와 같이 목적 별로 클래스를 분리하여 각각 생성하고 기능을 추가합니다.
<br>
이는 기능이 많아지더라도 어떤 클래스에 특정 기능이 구현되어 있을지 쉽게 확인할 수 있습니다. 이를 통해 유지보수하기 쉬운 코드를 짤 수 있습니다.

```java
class UserService {
    void signIn() {
        System.out.println("로그인 완료");
    }
    void signUp() {
        System.out.println("회원가입 완료");
    }
}

class ItemService {
    void buyItem() {
        Systtem.out.println("물품 구매 완료");
    }
}
```

## [ OCP (Open-Closed Principle, 개방 폐쇄 원칙) ]
OPC는 클래스는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 것입니다.
<br>
이는 기능이 추가될 때 기존 클래스 변경 없이 새로운 클래스로 인터페이스를 확장시켜 기능을 추가한다는 것입니다.

## [ OCP를 준수하지 않은 에제 ]
아래는 확장에 개방적이지 못하며 기능이 추가될 때 마다 새로운 메서드를 추가하고 있습니다. 
<br>
좋은 코드라고 생각할 수 있지만, 이는 결제 기능이 매우 많아질 경우 관리하기 매우 어렵습니다. 카드와 현금의 결제를 위해 결제 클래스 자체를 변경할 필요가 없다는 것입니다.

```java
class PayService {
    void cardPay() {
        System.out.println("카드 결제");
    }
    
    void moneyPay() {
        System.out.println("현금 결제");
    }
}
```

## [ OCP를 준수한 예제 ]
아래와 같이 PayService 인터페이스를 사용하여 새로운 결제 방식이 추가될 때마다 구현체를 만들어 확장해 사용합니다.
<br>
즉, 객체에 올바른 책임과 역할을 부여하게 됩니다. 결제에 대한 방식은 카드 클래스와 현금 클래스가 알아서 확장해서 사용할 뿐 결제 클래스 자체가 변경되지 않습니다.

```java
interface PayService {
    void pay();
}

class cardPayService implements PayService {
    @Override 
    void pay() {
        System.out.println("카드 결제");
    }
}

class moneyPayService implements PayService {
    @Override
    void pay() {
        System.out.println("현금 결제");
    }
}
```


## [ LSP (Liskov Substitution Principle, 리스코프 치환 원칙) ]
상위 타입의 객체를 하위 타입으로 바꾸어도 프로그램은 일관되게 동작해야 한다.


## [ ISP (Interface Segregation Principle, 인터페이스 분리 원칙) ]
클라이언트는 이용하지 않는 메소드에 의존하지 않도록 인터페이스를 분리해야 한다.

## [ DIP (Dependency Inversion Principle, 의존 역전 법칙) ]
클라이언트는 추상화(인터페이스)에 의존해야 하며, 구체화(구현된 클래스)에 의존해선 안된다.