---
title: "트랜잭션, MVCC, 인덱스 2019-11-26"
date: 2019-11-26 08:30:28 -0400
categories: Development
---
데이터베이스에서 다루는 트랜잭션, MVCC, 인덱스에 대해 알아봅니다.
<hr>

## [ 트랜잭션 ]
데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
```
# 사용자 A가 사용자 B에게 만원을 송금한다 

* 이 때 생기는 DB 작업
- 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
- 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경

현재 작업 단위 : 출금 UPDATE + 입금 UPDATE
-> 이를 통틀어 하나의 트랜잭션이라고 한다
-> 두 쿼리문 모두 성공적으로 완료되어야 트랜잭션이 완료되는 것이다 "Commit"
-> 두 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 되돌린다 "Rollback"
```

즉, 하나의 트랜잭션 설계를 잘 만드는 것이 데이터를 다룰 때 많은 이점을 가져다준다

```
# 트랜젝션의 4가지 특징

원자성(A) : 트랜잭션이 "Commit" 또는 "Rollback" 되어야 한다
-> 입금과 출금 중 하나만 처리된다면 원자성 위반이다 

일관성(C) : 트랜젝션의 작업 처리 결과는 항상 데이터의 일관성을 보장해야한다
-> 잔액이 없는데 출금이 가능해지면 일관성 위반이다

고립성(I) : 각각의 트랜젝션은 서로 간섭없이 독립적으로 수행해야 한다
-> 출금과 입금이 동시에 수행되더라도 출금 -> 입금 처럼 수행한 것처럼 해야 한다

지속성(D) : 트랜젝션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다
```

## [ 동시성 제어 ]
동시성 제어란 DBMS가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호간섭 작용에서 Database를 보호하는 것을 의미한다.
<br>
이렇듯 다수 사용자의 접속을 위해 동시성을 제어하는 방법에는 비관적 동시성 제어와 낙관적 동시성 제어가 있다.

## [ 비관적 동시성 제어 ]
비관적 동시성 제어란 말 그대로 비관적으로 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정하는 것이다.
<br>
데이터를 읽는 시점에 Lock을 걸고, 트랜잭션이 완료될 때까지 이를 유지한다.

## [ 낙관적 동시성 제어 ]
낙관적 동시성 제어란 비관적 동시성 제어와 반대로 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정하는 것이다.
<br>
데이터를 읽는 시점에 Lock을 걸지 않는 대신 수정 시점에 값이 변경되었는지 반드시 검사한다.

## [ MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어) ]
일반적인 Locking 매커니즘은 구현이 간단한 반면에 Lock을 오래 유지해야 하거나 동시성에 문제가 발생하는 등의 단점이 있다. 이러한 문제점을 해결하기 위해 MVCC가 등장하게 되었다.
<br>
MVCC 모델에서 데이터에 접근하는 사용자는 접근한 시점에서 데이터베이스의 Snapshot을 읽는다. 이 Snapshot 데이터에 대한 트랜잭션이 commit되기 전까지 다른 데이터베이스 사용자는 볼 수 없다.
<br>
사용자가 데이터를 업데이트하면 이전 데이터에 덮어씌우는 것이 아닌 새로운 버전의 데이터를 이전 버전의 데이터와 비교하여 변경된 내용을 기록한다.
<br>
이렇게 하나의 데이터에 대해 여러 버전의 데이터가 존재하게 되고, 사용자는 마지막 버전의 데이터를 읽게 된다.
<br>
이러한 구조를 지닌 MVCC의 특징을 정리하면 아래와 같다.

- 일반적인 RDBMS보다 매우 빠르게 작동
- 사용하지 않는 데이터가 계속 쌓이므로 데이터를 정리하는 시스템이 필요
- 데이터 버전이 충돌하면 애플리케이션 영역에서 문제를 해결해야 함

## [ 인덱스 ]
인덱스는 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.
<br>
책에서 원하는 내용이나 저자를 찾고자 할 때 색인을 추가하는데, 인덱스는 책의 색인과 같다.
<br>
인덱스를 활용하면, 데이터를 조회해야 하는 모든 쿼리의 성능이 향상된다. 만약 index를 사용하지 않은 컬럼을 조회해야 한다면 전체를 탐색하는 Full Scan을 수행해야 하는데, 이는 전체를 비교하여 탐색하므로 처리 속도가 떨어진다.

## [ 인덱스 관리 ]
DBMS는 index를 항상 최신의 상태로 유지하기 위해 INSERT, UPDATE, DELETE가 수행될 때 추가적인 연산을 해주어야 하며 그에 따른 오버헤드가 발생한다.

- INSERT: 새로운 데이터에 대한 인덱스를 추가
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가

## [ 인덱스 장점 ]
- 테이블을 조회하는 속도가 빨라진다.
- 데이터가 많을 경우 시스템의 부하를 줄일 수 있다.

## [ 인덱스 단점 ]
- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 잘못 사용하면 오히려 성능에서 역효과가 난다.
    - 규모가 작지 않은 테이블과 데이터의 중복도가 낮은 컬럼에서 사용해야 한다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.

## [ 인덱스의 자료구조 ]
